# peony-qt的扩展框架

## 什么是peony-qt的扩展？

peony-qt的扩展实际上是满足peony-qt扩展接口的插件，它以so库的形式在peony-qt执行过程中加载进peony-qt。peony-qt的扩展只关心peony-qt提供的接口，并不关心peony-qt的内部是怎么样的。

## 扩展框架

与peony-qt扩展不同，peony-qt的扩展框架不在意每个扩展具体干了什么。peony-qt的扩展框架需要考虑与peony-qt的协同——怎么定义一组接口？在什么时候加载扩展？什么时候显示扩展？什么时候触发扩展？也许在使用时没有一个扩展，但是框架依然存在，一些步骤依然会被执行，只是我们看不到而已。

## 为什么需要扩展框架

一个人的力量是有限的，一个项目也不可能包揽所有的工作，把所有的功能整合进同一个项目并且管理起来是一个十分复杂的工作，而且从程序设计的角度来看是十分不合理的。

peony（caja、nautilus）也考虑到了这一点，它们把一些复杂且不太属于文件管理器本职的工作使用扩展的形式来实现，在peony-qt中，我沿用了这样的设计思路。

## 把扩展框架从peony向peony-qt迁移

我之前也撰写过一篇文章简单的分析了peony的扩展机制，本质上是对glib接口/插件机制的一层封装；peony的扩展机制当然不适用于peony-qt，我们需要使用qt的插件机制对其进行重构，并且最终整合到我们的ui中去。

如果你对qt的插件机制比较了解，相信你应该能够很容易了解peony-qt的扩展框架，在这里简单介绍一下peony-qt扩展框架的实现思路：peony-qt的扩展一般被设计成一个工厂，在程序初始化时就被加载并且持续到程序结束，通过统一的接口进行扩展管理，在程序运行时，通过特定的ui交互进行触发。

## 扩展可能难于对应扩展框架的项目本身

一个扩展的复杂度不是由扩展框架决定的，实现一个扩展可能会比实现一个项目本身还要难，这也是我之前说整合项目不合理的一个重要因素。

在peony-qt的设计里，右键菜单、工具栏、导航栏、属性窗口甚至文件视图都是可扩展的，为了达到这样的设计，可能会增加编写代码和阅读代码的难度，但是考虑到今后长远的发展，这些工作都是值得去做的。

